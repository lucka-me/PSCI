import * as fs from 'fs';

export namespace locale {

    type LocaleCode = string;
    type SearchCallback = (path: string) => void;

    interface LocaleItem {
        [name: string]: string | LocaleItem;
    }

    class LocaleData {

        code: LocaleCode;
        data: LocaleItem = { }

        constructor(code: string) {
            this.code = code;
        }

        build() {
            const file = `${outputPath}/${this.code}.json`;
            fs.writeFileSync(file, JSON.stringify(this.data, null, 4));
            console.info(`Generated ${file}`);
        }

        get moduleName(): string {
            return this.code.replace('-', '_');
        }

        get importCode(): string {
            return `import ${this.moduleName} from './${this.code}.json'`;
        }

        get exportCode() {
            return `    '${this.code}': ${this.moduleName},`;
        }
    }

    const root = './src';   // Root path to search, will not included in namespaces
    const target = 'locales.json';
    const outputPath = './src/locales';
    const data = new Map<LocaleCode, LocaleData>();

    /**
     * Build locales files
     * @see Inspired by [Turnip-Calculator](https://github.com/elxris/Turnip-Calculator/blob/master/scripts/i18n.js)
     */
     export function build() {
        collect('');

        if (!fs.existsSync(outputPath)) {
            fs.mkdirSync(outputPath);
        }
        for (const localeData of data.values()) {
            localeData.build();
        }

        buildIndex();
    }

    /**
     * Search for target file recursively
     * @param path Search path, should not contain `root`
     * @param callback Triggered when target found
     */
    function collect(path: string) {
        const items = fs.readdirSync(`${root}/${path}`);
        for (const item of items) {
            if (item === target) {
                parse(path);
                continue;
            }
            const next = path.length > 0 ? `${path}/${item}` : item;
            if (fs.statSync(`${root}/${next}`).isDirectory()) {
                collect(next);
            }
        }
    }

    /**
     * Parse locale data from `locales.json`
     * @param path Path of the `locales.json`, will be used to generate namespaces
     */
    function parse(path: string) {
        console.info(`Load locales from ${root}/${path}/${target}`);
        const json = JSON.parse(fs.readFileSync(`${root}/${path}/${target}`, 'utf-8'));
        const spaces = path.split('/');
        for (const [lang, translations] of Object.entries(json)) {
            if (!data.has(lang)) data.set(lang, new LocaleData(lang));
            const localeData = data.get(lang);
            let targetItem: LocaleItem = localeData.data;
            for (const space of spaces) {
                let item = targetItem[space];
                if (!item || typeof item === 'string') {
                    item = { };
                    targetItem[space] = item;
                }
                targetItem = item;
            }
            Object.assign(targetItem, translations);
        }
    }

    /**
     * Build the `index.ts`
     */
    function buildIndex() {
        const codesImport: Array<string> = [];
        const codesExport: Array<string> = [];
        for (const localeData of data.values()) {
            codesImport.push(localeData.importCode);
            codesExport.push(localeData.exportCode);
        }
        const code = '// This file is generated by scripts/build-locals.ts\n'
            + codesImport.join('\n')
            + '\n\n'
            + 'export default {\n'
            + codesExport.join('\n')
            + '\n'
            + '};';
        const file = `${outputPath}/index.ts`;
        fs.writeFileSync(file, code);
        console.info(`Generated ${file}`);
    }
}