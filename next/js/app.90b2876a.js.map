{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/store/index.ts","webpack:///./src/service/google/auth/index.ts","webpack:///./src/service/google/drive/index.ts","webpack:///./src/service/google/index.ts","webpack:///./src/service/mari/parser.ts","webpack:///./src/service/mari/index.ts","webpack:///./src/service/index.ts","webpack:///./src/service/nomination/constants.ts","webpack:///./src/service/nomination/index.ts","webpack:///./src/service/preferences/index.ts","webpack:///./src/App.vue?8484","webpack:///./src/App.vue","webpack:///./src/App.vue?eabf","webpack:///./src/router/index.ts","webpack:///./src/main.ts","webpack:///./src/service/umi/index.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","installedCssChunks","jsonpScriptSrc","p","exports","module","l","e","promises","cssChunks","Promise","resolve","reject","href","fullhref","existingLinkTags","document","getElementsByTagName","tag","dataHref","getAttribute","rel","existingStyleTags","linkTag","createElement","type","onload","onerror","event","request","target","src","err","Error","code","parentNode","removeChild","head","appendChild","then","installedChunkData","promise","onScriptComplete","script","charset","timeout","nc","setAttribute","error","clearTimeout","chunk","errorType","realSrc","message","name","undefined","setTimeout","all","m","c","d","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","oe","console","jsonpArray","window","oldJsonpFunction","slice","State","Status","state","status","idle","gapiLoaded","gapiAuthed","nominations","getters","count","predicator","filter","mutations","payload","actions","AuthKit","events","authStatusChanged","navigator","onLine","gapi","load","this","initClient","client","init","apiKey","clientId","discoveryDocs","scope","join","auth2","getAuthInstance","isSignedIn","listen","signedIn","currentUser","getAuthResponse","access_token","signIn","signOut","GoogleDriveKit","ids","Map","filename","callback","listHandler","fileList","fileId","id","drive","files","alt","response","delete","set","list","q","pageSize","spaces","folder","fields","mimeType","blob","token","url","method","metadata","has","parents","form","FormData","append","Blob","JSON","stringify","authHeader","fetch","headers","Headers","Authorization","body","json","catch","auth","scriptTag","defer","async","parser","parse","mail","scanner","nomination","umi","StatusCode","Pending","confirmedTime","parseInt","internalDate","confirmationMailId","resultTime","resultMailId","header","matched","match","title","part","parts","partId","mailBody","base64","image","parseId","ScannerCode","Redacted","lngLat","Rejected","reasons","reason","matchedMainBody","mainBody","indexReasons","keywords","keyword","pos","search","sort","a","b","map","pair","lng","parseFloat","lat","text","unescape","decodeURIComponent","escape","atob","replace","ProgressItem","total","finished","Progress","lists","messages","onBuffer","onProgress","onFinish","clear","percent","left","ignoreMailIds","progress","alert","finish","buffer","flatMap","values","queries","keys","queryList","addList","listRequest","getListRequest","execute","handleListRequest","pageToken","gmail","users","userId","nextPageToken","newResponse","mailId","queryMessages","finishList","format","metadataHeaders","fullMail","subject","details","typedError","stack","finishMessage","service","Filename","mimeJSON","google","mari","_store","store","authed","commit","arrange","refresh","preferences","sync","download","processMails","upload","setStatus","syncing","getNominationsBlod","accessToken","succeed","migrate","legacy","importNominationsFile","input","accept","hidden","addEventListener","remove","file","fileReader","FileReader","jsonList","importNominations","readAsText","click","exportNominationsFile","anchor","URL","createObjectURL","clearNominations","save","processingMails","start","matchTargets","reduced","reduce","merged","merge","Array","targets","pendings","packs","checkScanner","Unknown","candidates","selected","matchData","pack","candidate","requestMatch","sources","jsonString","localStorage","getItem","setItem","StringKeyBase","StringKey","day","missing","messageParseErrorMissingId","messageParseErrorMissingTitle","messageParseErrorMissingImage","messageParseErrorInvalidId","messageParseErrorInvalidImage","test","Accepted","Reason","undeclared","includes","timestampSecondBound","imgUrl","toLowerCase","comparatorByTime","timeA","timeB","def","keySync","setSync","render","routes","path","component","router","history","App","use","mount","Scanner","icon","color","indexOf","duplicated","close","scanners","statuses","iconFA","quries","query","mapKeywords"],"mappings":"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","file":"js/app.90b2876a.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded CSS chunks\n \tvar installedCssChunks = {\n \t\t\"app\": 0\n \t}\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// script path function\n \tfunction jsonpScriptSrc(chunkId) {\n \t\treturn __webpack_require__.p + \"js/\" + ({\"dashboard~details~list~map~match~preferences\":\"dashboard~details~list~map~match~preferences\",\"dashboard\":\"dashboard\",\"details~map\":\"details~map\",\"details\":\"details\",\"map\":\"map\",\"list\":\"list\",\"match\":\"match\",\"preferences\":\"preferences\",\"mapbox\":\"mapbox\"}[chunkId]||chunkId) + \".\" + {\"dashboard~details~list~map~match~preferences\":\"795f8394\",\"dashboard\":\"b0f9548e\",\"details~map\":\"df86ac01\",\"details\":\"3e51764f\",\"map\":\"1dd701d4\",\"list\":\"85ccd492\",\"match\":\"fdb783cc\",\"preferences\":\"a280972a\",\"mapbox\":\"2dcfe6ae\"}[chunkId] + \".js\"\n \t}\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n\n\n \t\t// mini-css-extract-plugin CSS loading\n \t\tvar cssChunks = {\"dashboard~details~list~map~match~preferences\":1,\"dashboard\":1,\"details~map\":1,\"details\":1,\"map\":1,\"list\":1,\"match\":1,\"preferences\":1};\n \t\tif(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);\n \t\telse if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {\n \t\t\tpromises.push(installedCssChunks[chunkId] = new Promise(function(resolve, reject) {\n \t\t\t\tvar href = \"css/\" + ({\"dashboard~details~list~map~match~preferences\":\"dashboard~details~list~map~match~preferences\",\"dashboard\":\"dashboard\",\"details~map\":\"details~map\",\"details\":\"details\",\"map\":\"map\",\"list\":\"list\",\"match\":\"match\",\"preferences\":\"preferences\",\"mapbox\":\"mapbox\"}[chunkId]||chunkId) + \".\" + {\"dashboard~details~list~map~match~preferences\":\"7eed8b5f\",\"dashboard\":\"591e6d70\",\"details~map\":\"370ca2bc\",\"details\":\"c91c85a7\",\"map\":\"1cfb0654\",\"list\":\"6a9f041e\",\"match\":\"4e5ee524\",\"preferences\":\"2bbb92e5\",\"mapbox\":\"31d6cfe0\"}[chunkId] + \".css\";\n \t\t\t\tvar fullhref = __webpack_require__.p + href;\n \t\t\t\tvar existingLinkTags = document.getElementsByTagName(\"link\");\n \t\t\t\tfor(var i = 0; i < existingLinkTags.length; i++) {\n \t\t\t\t\tvar tag = existingLinkTags[i];\n \t\t\t\t\tvar dataHref = tag.getAttribute(\"data-href\") || tag.getAttribute(\"href\");\n \t\t\t\t\tif(tag.rel === \"stylesheet\" && (dataHref === href || dataHref === fullhref)) return resolve();\n \t\t\t\t}\n \t\t\t\tvar existingStyleTags = document.getElementsByTagName(\"style\");\n \t\t\t\tfor(var i = 0; i < existingStyleTags.length; i++) {\n \t\t\t\t\tvar tag = existingStyleTags[i];\n \t\t\t\t\tvar dataHref = tag.getAttribute(\"data-href\");\n \t\t\t\t\tif(dataHref === href || dataHref === fullhref) return resolve();\n \t\t\t\t}\n \t\t\t\tvar linkTag = document.createElement(\"link\");\n \t\t\t\tlinkTag.rel = \"stylesheet\";\n \t\t\t\tlinkTag.type = \"text/css\";\n \t\t\t\tlinkTag.onload = resolve;\n \t\t\t\tlinkTag.onerror = function(event) {\n \t\t\t\t\tvar request = event && event.target && event.target.src || fullhref;\n \t\t\t\t\tvar err = new Error(\"Loading CSS chunk \" + chunkId + \" failed.\\n(\" + request + \")\");\n \t\t\t\t\terr.code = \"CSS_CHUNK_LOAD_FAILED\";\n \t\t\t\t\terr.request = request;\n \t\t\t\t\tdelete installedCssChunks[chunkId]\n \t\t\t\t\tlinkTag.parentNode.removeChild(linkTag)\n \t\t\t\t\treject(err);\n \t\t\t\t};\n \t\t\t\tlinkTag.href = fullhref;\n\n \t\t\t\tvar head = document.getElementsByTagName(\"head\")[0];\n \t\t\t\thead.appendChild(linkTag);\n \t\t\t}).then(function() {\n \t\t\t\tinstalledCssChunks[chunkId] = 0;\n \t\t\t}));\n \t\t}\n\n \t\t// JSONP chunk loading for javascript\n\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n \t\t\t// a Promise means \"currently loading\".\n \t\t\tif(installedChunkData) {\n \t\t\t\tpromises.push(installedChunkData[2]);\n \t\t\t} else {\n \t\t\t\t// setup Promise in chunk cache\n \t\t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t\t\t});\n \t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n \t\t\t\t// start chunk loading\n \t\t\t\tvar script = document.createElement('script');\n \t\t\t\tvar onScriptComplete;\n\n \t\t\t\tscript.charset = 'utf-8';\n \t\t\t\tscript.timeout = 120;\n \t\t\t\tif (__webpack_require__.nc) {\n \t\t\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t\t\t}\n \t\t\t\tscript.src = jsonpScriptSrc(chunkId);\n\n \t\t\t\t// create error before stack unwound to get useful stacktrace later\n \t\t\t\tvar error = new Error();\n \t\t\t\tonScriptComplete = function (event) {\n \t\t\t\t\t// avoid mem leaks in IE.\n \t\t\t\t\tscript.onerror = script.onload = null;\n \t\t\t\t\tclearTimeout(timeout);\n \t\t\t\t\tvar chunk = installedChunks[chunkId];\n \t\t\t\t\tif(chunk !== 0) {\n \t\t\t\t\t\tif(chunk) {\n \t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n \t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n \t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n \t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n \t\t\t\t\t\t\terror.type = errorType;\n \t\t\t\t\t\t\terror.request = realSrc;\n \t\t\t\t\t\t\tchunk[1](error);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t\t\t}\n \t\t\t\t};\n \t\t\t\tvar timeout = setTimeout(function(){\n \t\t\t\t\tonScriptComplete({ type: 'timeout', target: script });\n \t\t\t\t}, 120000);\n \t\t\t\tscript.onerror = script.onload = onScriptComplete;\n \t\t\t\tdocument.head.appendChild(script);\n \t\t\t}\n \t\t}\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/next/\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([0,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","import { createStore } from 'vuex'\n\nimport Nomination, { Predicator } from '@/service/nomination';\n\nexport namespace State {\n    export enum Status {\n        idle,\n        processingMails,\n        requestMatch,\n        syncing\n    }\n}\n\nexport interface State {\n    status: State.Status;\n    gapiLoaded: boolean;\n    gapiAuthed: boolean;\n    nominations: Array<Nomination>;\n}\n\nexport default createStore<State>({\n    state: {\n        status: State.Status.idle,\n        gapiLoaded: false,\n        gapiAuthed: false,\n        nominations: [],\n    },\n    getters: {\n        empty(state: State) {\n            return state.nominations.length < 1;\n        },\n        count: (state: State) => (predicator: Predicator) => {\n            return state.nominations.filter(predicator).length;\n        }\n    },\n    mutations: {\n        setStatus(state: State, payload: State.Status) {\n            state.status = payload;\n        },\n        gapiLoaded(state: State) {\n            state.gapiLoaded = true;\n        },\n        setGAPIAuthed(state: State, payload: boolean) {\n            state.gapiAuthed = payload;\n        },\n        setNominations(state: State, payload: Array<Nomination>) {\n            state.nominations = payload;\n        }\n    },\n    actions: {\n    },\n    modules: {\n    }\n});\n","export type AuthStatusChangedCallback = (signedIn: boolean) => void;\ntype ErrorCallback = (message: string) => void;\n\n/**\n * Events for {@link AuthKit}\n */\ninterface AuthKitEvents {\n    authStatusChanged: AuthStatusChangedCallback;   // Triggered when sign-in or sign-out\n    error: ErrorCallback;   // Triggered when gapi.auth error occures\n}\n\n/**\n * Handle GAPI authentication\n */\nexport default class AuthKit {\n\n    events: AuthKitEvents = {\n        authStatusChanged: () => { },\n        error: () => { },\n    };\n\n    init() {\n        if (navigator.onLine) {\n            gapi.load('client:auth2', () => this.initClient());\n        }\n    }\n\n    /**\n     * Initialize the GAPI and load client libraries\n     */\n    private initClient() {\n        gapi.client.init({\n            apiKey: 'AIzaSyCqIaS8UizqjWrIKm5zV3_S8EffCWjKR-A',\n            clientId: '361295761775-qshg0f5buh495dhubp4v5bignk7i5dh1.apps.googleusercontent.com',\n            discoveryDocs: [\n                'https://www.googleapis.com/discovery/v1/apis/gmail/v1/rest',\n                'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'\n            ],\n            scope: [\n                'https://www.googleapis.com/auth/gmail.readonly',\n                'https://www.googleapis.com/auth/drive.file',\n                'https://www.googleapis.com/auth/drive.appdata'\n            ].join(' '),\n        }).then(\n            () => {\n                // Listen for sign-in state changes.\n                gapi.auth2.getAuthInstance().isSignedIn.listen(this.events.authStatusChanged);\n                // Handle the initial sign-in state.\n                this.events.authStatusChanged(this.signedIn);\n            },\n            this.events.error\n        );\n    }\n\n    /**\n     * Get authentication status, signed in or not\n     */\n    get signedIn() {\n        return navigator.onLine && gapi.auth2.getAuthInstance().isSignedIn.get();\n    }\n\n    /**\n     * Get the token for accessing the account\n     */\n    get accessToken() {\n        return gapi.auth2.getAuthInstance().currentUser.get().getAuthResponse().access_token;\n    }\n\n    /**\n     * Sign in\n     */\n    signIn() {\n        gapi.auth2.getAuthInstance().signIn();\n    }\n\n    /**\n     * Sign out\n     */\n    signOut() {\n        gapi.auth2.getAuthInstance().signOut();\n    }\n}","export type DownloadCallback = (file?: gapi.client.drive.File) => boolean;\ntype UploadCallback = (succeed: boolean, message?: string) => void;\n\n/**\n * Download and upload from / to Google Drive\n */\nexport default class GoogleDriveKit {\n\n    private static readonly folder = 'appDataFolder';   // The private folder in Google Drive\n\n    private ids: Map<string, string> = new Map();   // ID of files, <filename, id>\n\n    /**\n     * Download file from Google Drive.\n     * \n     * The caller should decide whether to delete the current one & download\n     * next one or not by return a boolean\n     * \n     * @param filename Name of the file to download\n     * @param callback Triggered when a file is downloaded\n     */\n    download(filename: string, callback: DownloadCallback) {\n        const listHandler = (fileList: Array<gapi.client.drive.File>) => {\n            if (fileList.length < 1) {\n                callback();\n                return;\n            }\n            const fileId = fileList[0].id!;\n            gapi.client.drive.files.get({\n                fileId: fileId,\n                alt: 'media'\n            }).then((response: gapi.client.Response<gapi.client.drive.File>) => {\n                if (callback(response.result)) {\n                    gapi.client.drive.files.delete({ fileId: fileId });\n                    fileList.splice(0, 1);\n                    listHandler(fileList);\n                } else {\n                    this.ids.set(filename, fileId);\n                }\n            });\n        };\n\n        gapi.client.drive.files.list({\n            q: `name = '${filename}'`,\n            pageSize: 10,\n            spaces: GoogleDriveKit.folder,\n            fields: 'files(id)'\n        }).then((response: gapi.client.Response<gapi.client.drive.FileList>) => {\n            const files = response.result.files;\n            if (!files) {\n                callback();\n                return;\n            }\n            listHandler(files);\n        });\n    }\n\n    /**\n     * Upload file to Google Drive\n     * @param filename Filename to upload\n     * @param mimeType MIME type of the file\n     * @param blob Content to upload\n     * @param token The Google account access token\n     * @param callback Triggered when process finished\n     */\n    upload(filename: string, mimeType: string, blob: Blob, token: string, callback: UploadCallback) {\n        // Ref: https://gist.github.com/tanaikech/bd53b366aedef70e35a35f449c51eced\n        let url = '';\n        let method = '';\n        const metadata: any = {\n            name: filename,\n            mimeType: mimeType,\n        };\n        // Using parent in Update will cause 403\n        if (this.ids.has(filename)) {\n            method = 'PATCH';\n            url = `https://www.googleapis.com/upload/drive/v3/files/${this.ids.get(filename)}?uploadType=multipart`;\n        } else {\n            method = 'POST';\n            url = 'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart';\n            metadata.parents = [ GoogleDriveKit.folder ];\n        }\n        const form = new FormData();\n        form.append('metadata', new Blob([JSON.stringify(metadata)], { type: mimeType }));\n        form.append('file', blob);\n        const authHeader = `Bearer ${token}`;\n        fetch(url, {\n            method: method,\n            headers: new Headers({ Authorization: authHeader }),\n            body: form,\n        })\n            .then(response => response.json())\n            .then(response => {\n                if (response && response.id) {\n                    this.ids.set(filename, response.id);\n                    callback(true);\n                } else {\n                    callback(false, response.message);\n                }\n            })\n            .catch(() => callback(false));\n    }\n}","import AuthKit from './auth';\nimport GoogleDriveKit from './drive';\n\ntype BasicCallback = () => void;\n\nexport default class GoogleKit {\n\n    auth = new AuthKit();\n    drive = new GoogleDriveKit();\n\n    init(callback: BasicCallback) {\n        const scriptTag = document.createElement('script');\n        scriptTag.src = 'https://apis.google.com/js/api.js';\n        scriptTag.defer = true;\n        scriptTag.async = true;\n        scriptTag.onload = callback;\n        document.head.append(scriptTag);\n    }\n}","import { umi } from '@/service/umi';\nimport Nomination, { LngLat } from '@/service/nomination';\n\n/**\n * Parsers for mail content\n */\nexport namespace parser {\n    /**\n     * Parse the full mail to nomination\n     * @param mail The full mail to parse\n     * @param status Statue of the mail\n     * @param scanner Scanner of the mail\n     * @returns The parsed nomination\n     */\n    export function parse(\n        mail: gapi.client.gmail.Message,\n        status: umi.StatusCode,\n        scanner: umi.ScannerCode\n    ): Nomination {\n        const nomination = new Nomination();\n        nomination.status = status;\n        if (status === umi.StatusCode.Pending) {\n            nomination.confirmedTime = parseInt(mail.internalDate!);\n            nomination.confirmationMailId = mail.id!;\n        } else {\n            nomination.resultTime = parseInt(mail.internalDate!);\n            nomination.resultMailId = mail.id!;\n        }\n\n        // Subject -> Title\n        for (const header of mail.payload!.headers!) {\n            if (header.name === 'Subject') {\n                const matched = header.value!.match(/[:：](.+)/);\n                if (matched && matched.length > 1) {\n                    nomination.title = matched[1];\n                }\n                break;\n            }\n        }\n\n        // Body -> image, id, lngLat and reason\n        for (const part of mail.payload!.parts!) {\n            if (part.partId !== '1') continue;\n            const mailBody = base64(part.body!.data!);\n            const matched = mailBody.match(/googleusercontent\\.com\\/([0-9a-zA-Z\\-\\_]+)/);\n            if (matched && matched.length > 1) {\n                nomination.image = matched[1];\n                nomination.id = Nomination.parseId(nomination.image);\n            }\n            if (scanner === umi.ScannerCode.Redacted && status !== umi.StatusCode.Pending) {\n                nomination.lngLat = lngLat(mailBody);\n            }\n            if (status === umi.StatusCode.Rejected) {\n                nomination.status = umi.StatusCode.Rejected;\n                nomination.reasons = reason(mailBody, scanner);\n            }\n            break;\n        }\n        return nomination;\n    }\n\n    /**\n     * Parse the reject reason from mail body\n     * @param mail Body (content) of the mail\n     * @param scanner The scanner key for fetch the keywords\n     */\n    function reason(mail: string, scanner: umi.ScannerCode): Array<umi.ReasonCode> {\n        const matchedMainBody = mail.match(/(\\n|\\r|.)+?\\-NianticOps/);\n        if (!matchedMainBody || matchedMainBody.length < 1) {\n            return [ ];\n        }\n        const mainBody = matchedMainBody[0];\n\n        const indexReasons: Array<[number, umi.ReasonCode]> = []\n        for (const [code, reason] of umi.reason) {\n            const keywords = reason.keywords.get(scanner);\n            if (!keywords) continue;\n            for (const keyword of keywords) {\n                const pos = mainBody.search(keyword);\n                if (pos < 0) continue;\n                indexReasons.push([pos, code]);\n                break;\n            }\n        }\n        return indexReasons\n            .sort((a, b) => a[0] > b[0] ? 1 : -1)\n            .map((pair) => pair[1]);\n    }\n\n    /**\n     * Parse the location from mail body, only redacted mails contain location\n     * @param mail Body (content) of the mail\n     */\n    function lngLat(mail: string): LngLat | undefined {\n        const matched = mail.match(/www\\.ingress\\.com\\/intel\\?ll\\=([\\.\\d]+),([\\.\\d]+)/);\n        if (!matched || matched.length < 3) {\n            return undefined;\n        }\n        return {\n            lng: parseFloat(matched[2]),\n            lat: parseFloat(matched[1])\n        };\n    }\n\n    /**\n     * Decode base64\n     * @param text Base64 encoded text\n     * @see https://nelluil.postach.io/post/btoa-atob-zhi-yuan-zhong-wen-de-fang-fa\n     * @see https://cnodejs.org/topic/4fd6b7ba839e1e581407aac8\n     */\n    function base64(text: string) {\n        return unescape(\n            decodeURIComponent(\n                escape(window.atob(text.replace(/\\-/g, '+').replace(/\\_/g, '/')))\n            )\n        );\n    }\n}","import { umi } from '@/service/umi';\nimport Nomination from '@/service/nomination';\n\nimport { parser } from './parser';\n\ntype BasicCallback = () => void;\ntype MessageCallback = (message: string) => void;\ntype FinishCallback = (nominations: Array<Nomination>) => void;\nexport type ProgressCallback = (percent: number) => void;\n\n/**\n * Events for {@link Mari}\n */\ninterface MariEvents {\n    alert:      MessageCallback;    // Triggered when alert should be displayed\n    buffer:     ProgressCallback;   // Triggered when buffer (secondary progress) updates\n    progress:   ProgressCallback,   // Triggered when main progress update\n    finish:     FinishCallback;     // Triggered when processes all finish\n}\n\n/**\n * Item of {@link Progress}\n */\nclass ProgressItem {\n    total: number = 0;\n    finished: number = 0;\n\n    clear() {\n        this.total = 0;\n        this.finished = 0;\n    }\n\n    /**\n     * Detect if the progress is not 100%\n     */\n    get left() {\n        return this.finished < this.total;\n    }\n\n    /**\n     * The percentage of progress\n     */\n    get percent() {\n        return this.total === 0 ? 0.0 : (this.finished / this.total);\n    }\n}\n\n/**\n * Manage the progress of mail processing\n */\nclass Progress {\n\n    lists = new ProgressItem();\n    messages = new ProgressItem();\n\n    onBuffer    : ProgressCallback  = () => { };    // Triggered when a list finished\n    onProgress  : ProgressCallback  = () => { };    // Triggered when a message finished if all lists are finished\n    onFinish    : BasicCallback     = () => { };    // Triggered when all lists and messages are finished\n\n    /**\n     * Clear all progress\n     */\n    clear() {\n        this.lists.clear();\n        this.messages.clear();\n    }\n\n    /**\n     * Add a WIP list\n     */\n    addList() {\n        this.lists.total += 1;\n    }\n\n    /**\n     * Finish a list and check finish\n     * @param messages Count of the messages to process\n     */\n    finishList(messages: number) {\n        this.lists.finished += 1;\n        this.messages.total += messages;\n        this.onBuffer(this.lists.percent);\n        if (!this.left) {\n            this.onFinish();\n        }\n    }\n\n    /**\n     * Finish a message and check finish\n     */\n    finishMessage() {\n        this.messages.finished += 1;\n        if (!this.lists.left) {\n            this.onProgress(this.messages.percent);\n            if (!this.left) {\n                this.onFinish();\n            }\n        }\n    }\n\n    /**\n     * Detect if there is list or message left\n     */\n    private get left() {\n        return this.lists.left || this.messages.left;\n    }\n}\n\n/**\n * Query and process mails\n */\nexport default class Mari {\n\n    private ignoreMailIds: Array<string> = [];      // List of ids of mails that should be ignored\n    private nominations: Array<Nomination> = [];    // List of nominations\n\n    private progress = new Progress();  // Progress manager\n\n    events: MariEvents = {\n        alert:  () => {},\n        finish: () => {},\n        buffer: () => {},\n        progress: () => {},\n    };\n\n    /**\n     * Initiate Mari\n     */\n    init() {\n        this.progress.onBuffer = (percent) => {\n            this.events.buffer(percent);\n        }\n        this.progress.onProgress = (percent) => {\n            this.events.progress(percent);\n        }\n        this.progress.onFinish = () => {\n            this.events.finish(this.nominations);\n        }\n    }\n\n    /**\n     * Start the process\n     * @param nominations Existing nominations\n     */\n    start(nominations: Array<Nomination>) {\n        this.nominations = nominations.map(nomination => nomination);\n        this.progress.lists.clear();\n        this.progress.messages.clear();\n\n        // Ignore the mails already in the list\n        this.ignoreMailIds = this.nominations.flatMap(nomination => {\n            return nomination.resultMailId.length > 0 ? [ nomination.confirmationMailId, nomination.resultMailId ] : [ nomination.confirmationMailId ];\n        });\n        for (const status of umi.status.values()) {\n            for (const scanner of status.queries.keys()) {\n                this.queryList(status.code, scanner);\n            }\n        }\n    }\n\n    /**\n     * Start to query message list\n     * @param status Status to query\n     * @param scanner Scanner to query\n     */\n    private queryList(status: umi.StatusCode, scanner: umi.ScannerCode) {\n        this.progress.addList();\n        const listRequest = Mari.getListRequest(undefined, status, scanner);\n        listRequest.execute((response) => {\n            this.handleListRequest(response, [], status, scanner);\n        });\n    }\n\n    /**\n     * Generate a request for mail list\n     * @param pageToken Token for target page\n     * @param status Status to query\n     * @param scanner Scanner to query, must exist in the `queries` of the status\n     */\n    private static getListRequest(pageToken: string | undefined, status: umi.StatusCode, scanner: umi.ScannerCode) {\n        return gapi.client.gmail.users.messages.list({\n            userId: 'me',\n            q: umi.status.get(status)!.queries.get(scanner)!,\n            pageToken: pageToken\n        });\n    }\n\n    /**\n     * Handle the respose of mail list request, request next page or goto next step\n     * @param response Response of the request\n     * @param list Mail list\n     * @param status Status of the list\n     * @param scanner Scanner of the list\n     */\n    private handleListRequest(\n        response: gapi.client.Response<gapi.client.gmail.ListMessagesResponse>,\n        list: Array<gapi.client.gmail.Message>,\n        status: umi.StatusCode,\n        scanner: umi.ScannerCode\n    ) {\n        if (response.result.messages) {\n            list.push(...response.result.messages);\n        }\n        if (response.result.nextPageToken) {\n            const request = Mari.getListRequest(response.result.nextPageToken, status, scanner);\n            request.execute((newResponse) => {\n                this.handleListRequest(newResponse, list, status, scanner);\n            });\n        } else {\n            for (let i = list.length - 1; i >= 0; i--) {\n                for (const mailId of this.ignoreMailIds) {\n                    if (list[i].id === mailId) {\n                        list.splice(i, 1);\n                        break;\n                    }\n                }\n            }\n            this.queryMessages(list, status, scanner);\n        }\n    }\n\n    /**\n     * Process mail (id) list\n     * @param list Complete mail list\n     * @param status Status of the list\n     * @param scanner Scanner of the list\n     */\n    private queryMessages(list: Array<gapi.client.gmail.Message>, status: umi.StatusCode, scanner: umi.ScannerCode) {\n        this.progress.finishList(list.length);\n\n        for (const mail of list) {\n            if (!mail.id) continue;\n            gapi.client.gmail.users.messages.get({\n                userId: 'me',\n                id: mail.id,\n                format: 'full',\n                metadataHeaders: 'Subject'\n            }).execute((response: gapi.client.Response<gapi.client.gmail.Message>) => {\n                const fullMail = response.result;\n                try {\n                    const nomination = parser.parse(fullMail, status, scanner);\n                    this.nominations.push(nomination);\n                } catch (error) {\n                    let subject = '';\n                    for (const header of fullMail.payload!.headers!) {\n                        if (header.name === 'Subject') {\n                            subject = header.value!;\n                            break;\n                        }\n                    }\n                    let details: string = error;\n                    if ('message' in error) {\n                        const typedError = error as Error;\n                        details = typedError.stack || typedError.message;\n                    }\n                    // this.events.alert(i18next.t('message:service.mari.reportParserError', {\n                    //     subject: subject,\n                    //     message: `[${keys.scanner}:${keys.status}]${details}`\n                    // }));\n                    this.events.alert(`message:service.mari.reportParserError ${subject} [${status}:${scanner}]${details}`);\n                }\n\n                this.progress.finishMessage();\n            });\n        }\n    }\n}\n","import { Store } from 'vuex'\n\nimport { State } from '@/store';\nimport GoogleKit from './google';\nimport Mari from './mari';\nimport Nomination from './nomination';\nimport { preferences } from './preferences';\nimport { umi } from './umi';\n\nexport namespace service {\n\n    type DownloadCallback = (count: number) => void;\n    type UploadCallback = (succeed: boolean, message?: string) => void;\n\n    enum Filename {\n        nominations = 'nominations.json',\n        legacy = 'potori.json'\n    }\n\n    export interface MatchPack {\n        target: Nomination;\n        candidates: Array<Nomination>;\n        selected: string;\n    }\n\n    export interface MatchData {\n        packs: Array<MatchPack>;\n        callback: () => void;\n    }\n\n    const mimeJSON = 'application/json';\n\n    const google = new GoogleKit();\n    const mari = new Mari();\n    let _store: Store<State>;\n\n    export const matchData: MatchData = {\n        packs: [],\n        callback: () => { }\n    };\n\n    export function init(store: Store<State>) {\n        _store = store;\n\n        load();\n\n        google.init(() => {\n            google.auth.events.authStatusChanged = (authed) => {\n                _store.commit('setGAPIAuthed', authed);\n                _store.commit('gapiLoaded');\n            };\n            google.auth.init();\n\n            mari.events.finish = (nominations) => {\n                arrange(nominations);\n            };\n            mari.init();\n        });\n    }\n\n    export function signIn() {\n        google.auth.signIn();\n    }\n\n    export function signOut() {\n        google.auth.signOut();\n    }\n\n    export function refresh() {\n        if (preferences.google.sync()) {\n            download(Filename.nominations, () => {\n                processMails();\n            })\n        } else {\n            processMails();\n        }\n    }\n\n    export function sync() {\n        download(Filename.nominations, () => {\n            upload(() => {\n\n            });\n        });\n    }\n\n    export function upload(callback: UploadCallback) {\n        setStatus(State.Status.syncing);\n        const blob = getNominationsBlod();\n        google.drive.upload(Filename.nominations, mimeJSON, blob, google.auth.accessToken, (succeed, message) => {\n            setStatus(State.Status.idle);\n            callback(succeed, message);\n        });\n    }\n\n    export function migrate() {\n        download(Filename.legacy, (count) => {\n            // Alert count\n        });\n    }\n\n    export function importNominationsFile() {\n        const input = document.createElement('input');\n        input.type = 'file';\n        input.accept = 'json';\n        input.hidden = true;\n        input.addEventListener('change', () => {\n            setTimeout(() => {\n                input.remove();\n            }, 1000);\n            if (!input.files || input.files.length < 1) return;\n            const file = input.files[0];\n            const fileReader = new FileReader();\n            fileReader.onload = () => {\n                if (typeof fileReader.result !== 'string') return;\n                try {\n                    const jsonList = JSON.parse(fileReader.result) as Array<any>;\n                    importNominations(jsonList);\n                } catch (error) {\n\n                }\n            };\n            fileReader.readAsText(file);\n        }, false);\n        document.body.append(input);\n        input.click();\n    }\n\n    export function exportNominationsFile() {\n        const anchor = document.createElement('a');\n        anchor.href = URL.createObjectURL(getNominationsBlod());\n        anchor.download = Filename.nominations;\n        anchor.hidden = true;\n        document.body.append(anchor);\n        anchor.click();\n        anchor.remove();\n    }\n\n    export function clearNominations() {\n        _store.commit('setNominations', []);\n        save();\n    }\n\n    function processMails() {\n        setStatus(State.Status.processingMails);\n        mari.start(_store.state.nominations);\n    }\n\n    function arrange(nominations: Array<Nomination>) {\n        const matchTargets: Array<Nomination> = [];\n        const reduced = nominations.reduce((list, nomination) => {\n            if (nomination.id.length < 1) {\n                matchTargets.push(nomination);\n                return list;\n            }\n            // Merge\n            let merged = false;\n            for (const target of list) {\n                if (target.merge(nomination)) {\n                    merged = true;\n                    break;\n                }\n            }\n            if (!merged) {\n                list.push(nomination);\n            }\n            return list;\n        }, new Array<Nomination>());\n        if (matchTargets.length > 0) {\n            match(matchTargets, reduced);\n        } else {\n            if (preferences.google.sync()) {\n                upload(() => { finish(reduced); });\n            } else {\n                finish(reduced);\n            }\n        }\n    }\n\n    /**\n     * Some result mails don't contain image URL, should match from pending nominations manually.\n     * @param targets Nominations without image\n     * @param list Normal nominations\n     */\n    function match(targets: Array<Nomination>, list: Array<Nomination>) {\n        const pendings = list.filter(umi.status.get(umi.StatusCode.Pending)!.predicator);\n        const packs: Array<MatchPack> = [];\n        for (const target of targets) {\n            const checkScanner = target.scanner !== umi.ScannerCode.Unknown;\n            const candidates = pendings.filter((nomination) => {\n                if (nomination.title !== target.title) return false;\n                if (nomination.confirmedTime >= target.resultTime) return false;\n                if (checkScanner && nomination.scanner !== umi.ScannerCode.Unknown && nomination.scanner !== nomination.scanner) return false;\n                return true;\n            });\n            if (candidates.length < 1) continue;\n            packs.push({ target: target, candidates: candidates, selected: '' });\n        }\n        if (packs.length < 1) {\n            finish(list);\n        } else {\n            matchData.packs = packs;\n            matchData.callback = () => {\n                matchData.callback = () => { };\n                for (const pack of matchData.packs) {\n                    if (pack.selected.length < 1) continue;\n                    for (const candidate of pack.candidates) {\n                        if (candidate.id !== pack.selected) continue;\n                        pack.target.image = candidate.image;\n                        pack.target.id = candidate.id;\n                        break;\n                    }\n                    if (pack.target.id.length < 1) continue;\n                    for (const nomination of list) {\n                        nomination.merge(pack.target);\n                    }\n                }\n                matchData.packs = [];\n                finish(list);\n            };\n            setStatus(State.Status.requestMatch);\n        }\n    }\n\n    function finish(list: Array<Nomination>) {\n        _store.commit('setNominations', list);\n        save();\n        setStatus(State.Status.idle);\n    }\n\n    function setStatus(status: State.Status) {\n        _store.commit('setStatus', status);\n    }\n\n    function download(file: Filename, callback: DownloadCallback) {\n        setStatus(State.Status.syncing);\n        google.drive.download(file, (file) => {\n            if (!file) {\n                callback(0);\n                return false;\n            }\n            try {\n                const count = importNominations(file as Array<any>);\n                callback(count);\n            } catch (error) {\n                return true;\n            }\n            return false;\n        });\n    }\n\n    function importNominations(jsonList: Array<any>): number {\n        let count = 0;\n        try {\n            const sources = jsonList.map(json => Nomination.parse(json));\n            const nominations = _store.state.nominations.map((nomination) => nomination);\n            for (const nomination of sources) {\n                let merged = false;\n                for (const target of nominations) {\n                    merged = target.merge(nomination);\n                    if (merged) {\n                        count += 1;\n                        break;\n                    }\n                }\n                if (merged) continue;\n                nominations.push(nomination);\n            }\n            _store.commit('setNominations', nominations);\n            save();\n        } catch (error) {\n            count = 0;\n        }\n        return count;\n    }\n\n    function getNominationsBlod(): Blob {\n        const jsonList = _store.state.nominations.map((nomination) => nomination.json);\n        return new Blob(\n            [ JSON.stringify(jsonList, null, 4) ],\n            { type: mimeJSON }\n        )\n    }\n\n    function load() {\n        const jsonString = localStorage.getItem('potori.nominations');\n        if (jsonString) {\n            try {\n                const jsonList = JSON.parse(jsonString) as Array<any>;\n                const nominations = jsonList.map(json => Nomination.parse(json));\n                _store.commit('setNominations', nominations);\n            } catch (error) {\n                \n            }\n        }\n    }\n\n    function save() {\n        localStorage.setItem(\n            'potori.nominations',\n            JSON.stringify(_store.state.nominations.map(nomination => nomination.json))\n        );\n    }\n\n    /**\n     * Match the first target in queue and first candidate in its cadidates\n     * Next step is {@link sort}\n     * @param queue Queue to match\n     */\n    /*\n    function manuallyMatch(queue: Array<MatchItem>) {\n        if (queue.length < 1) {\n            sort();\n            return;\n        }\n        const item = queue[0];\n        if (item.candidates.length < 1) {\n            queue.shift();\n            manuallyMatch(queue);\n            return;\n        }\n        const candidate = item.candidates[0];\n        events.match(item.target, candidate, (matched) => {\n            if (matched) {\n                candidate.status = item.target.status;\n                candidate.resultTime = item.target.resultTime;\n                candidate.resultMailId = item.target.resultMailId;\n                queue.shift();\n                for (const item of queue) {\n                    const index = item.candidates.indexOf(candidate);\n                    if (index < 0) continue;\n                    item.candidates.splice(index, 1);\n                }\n            } else {\n                item.candidates.shift();\n            }\n            manuallyMatch(queue);\n        });\n    }\n    */\n\n    /**\n     * Query locations\n     * Next step is {@link event.idle}\n     */\n    /*\n    function queryLocation() {\n        const finished = () => {\n            events.idle();\n        };\n\n        // Query locations\n        const listNoLocation = nominations.reduce((list, nomination) => {\n            if (!nomination.lngLat) list.push(nomination);\n            return list;\n        }, new Array<Nomination>());\n        if (listNoLocation.length < 1) {\n            finished();\n            return;\n        }\n        let count = 0;\n        events.progressUpdate(0.9);\n        const countUp = () => {\n            count += 1;\n            events.progressUpdate(0.9 + (count / listNoLocation.length * 0.1));\n            if (count === listNoLocation.length) finished();\n        };\n        for (const nomination of listNoLocation) {\n            bs.queryLocation(\n                nomination,\n                (lngLat) => {\n                    nomination.lngLat = lngLat;\n                    countUp();\n                },\n                countUp\n            );\n        }\n    }\n    */\n\n    /**\n     * Open local file\n     */\n    /*\n    export function open() {\n        events.clear();\n        const onload = (content: string) => {\n            const resultNominations = Parser.nominations(content);\n            if (resultNominations.matched) {\n                nominations.length = 0;\n                nominations.push(...resultNominations.nominations);\n                arrange();\n                return;\n            }\n            const resultBsData = Parser.bsData(content);\n            if (resultBsData.matched) {\n                bs.data = resultBsData.data;\n                if (nominations.length > 0) {\n                    events.bsUpdate();\n                }\n                events.info(i18next.t('message:service.loadBsData'));\n                return;\n            }\n            // Parse as other contents\n        };\n        file.local.open(onload, events.alert);\n    }\n    */\n\n    /**\n     * Import JSON from Wayfarer API response\n     * @param raw Raw JSON\n     */\n    /*\n    export function importJSON(raw: string) {\n        let parsed;\n        try {\n            parsed = JSON.parse(raw);\n        } catch (error) {\n            events.alert(i18next.t('message:service.parseError'));\n            return;\n        }\n        if (!parsed.result || parsed.result.length < 1) {\n            events.alert(i18next.t('message:service.invalidData'));\n            return;\n        }\n        const mapNomination = new Map<string, Nomination>();\n        \n        for (const monination of nominations) {\n            mapNomination.set(monination.id, monination);\n        }\n        let count = 0;\n        for (const nomination of parsed.result) {\n            const imageUrl = nomination.imageUrl.replace('https://lh3.googleusercontent.com/', '');\n            const id = Nomination.parseId(imageUrl);\n            if (!mapNomination.has(id)) continue;\n\n            const monination = mapNomination.get(id);\n            monination.title = nomination.title;\n            monination.lngLat = {\n                lng: parseFloat(nomination.lng),\n                lat: parseFloat(nomination.lat)\n            };\n            count += 1;\n        }\n        events.info(i18next.t('message:service.imported', { count: count }));\n        events.idle();\n    }\n    */\n    \n    /**\n     * Query Brainstorming firebase and update local bs data\n     */\n    /*\n    export function updateBsData() {\n        bs.update(nominations, () => {\n            events.bsUpdate();\n            events.info(i18next.t('message:service.bsDataUpdated'));\n        });\n    }\n    */\n\n    /**\n     * Clear Brainstorming database\n     */\n    /*\n    export function clearBsData() {\n        bs.clear();\n    }\n    */\n}","const StringKeyBase = 'service.nomination';\n\nexport const StringKey = {\n    day: `${StringKeyBase}.day`,\n    missing: `${StringKeyBase}.missing`,\n\n    messageParseErrorMissingId: `message:${StringKeyBase}.parseErrorMissingId`,\n    messageParseErrorMissingTitle: `message:${StringKeyBase}.parseErrorMissingTitle`,\n    messageParseErrorMissingImage: `message:${StringKeyBase}.parseErrorMissingImage`,\n    messageParseErrorInvalidId: `message:${StringKeyBase}.parseErrorInvalidId`,\n    messageParseErrorInvalidImage: `message:${StringKeyBase}.parseErrorInvalidImage`,\n}","import { umi } from '@/service/umi';\n\nimport { StringKey } from './constants';\n\n/**\n * Location\n */\nexport interface LngLat {\n    lng: number;    // Longitude\n    lat: number;    // Latitude\n}\n\n/**\n * Nomination data\n */\nexport default class Nomination {\n\n    private static timestampSecondBound = 1E12;\n\n    /**\n     * Comparator for sorting by time\n     */\n    static readonly comparatorByTime = (a: Nomination, b: Nomination) => {\n        const timeA = a.resultTime ? a.resultTime : a.confirmedTime;\n        const timeB = b.resultTime ? b.resultTime : b.confirmedTime;\n        return timeA < timeB ? 1 : -1;\n    };\n\n    id = '';    // Short ID, also brainstorming ID\n    title = ''; // Title\n    image = ''; // Hash part of the image URL\n    scanner: umi.ScannerCode = umi.ScannerCode.Unknown; // Scanner of the nomination\n\n    status: umi.StatusCode = umi.StatusCode.Pending;  // Status code\n    reasons: Array<umi.ReasonCode> = [];    // Reason codes\n\n    confirmedTime = 0;          // Confirmed time, the timestamp of confirmation mail\n    confirmationMailId = '';    // ID of confirmation mail\n    resultTime: number = 0;     // Result time, the timestamp of result mail\n    resultMailId: string = \"\";  // ID of result mail\n\n    lngLat?: LngLat = undefined;    // Location\n\n    /**\n     * Get the image URL\n     */\n    get imageUrl(): string {\n        return `https://lh3.googleusercontent.com/${this.image}`;\n    }\n\n    /**\n     * Get Intel Maps URL\n     */\n    get intelUrl(): string {\n        if (this.lngLat) {\n            return `https://intel.ingress.com/intel?ll=${this.lngLat.lat},${this.lngLat.lng}&z=18`;\n        } else {\n            return 'https://intel.ingress.com/intel';\n        }\n    }\n\n    /**\n     * Get Brainstorming watermeter URL\n     */\n    get bsUrl(): string {\n        return `https://brainstorming.azurewebsites.net/watermeter.html#${this.id}`;\n    }\n\n    get scannerData(): umi.Scanner {\n        return umi.scanner.get(this.scanner)!;\n    }\n\n    /**\n     * Get status data\n     */\n    get statusData(): umi.Status {\n        return umi.status.get(this.status)!;\n    }\n\n    /**\n     * Get data of reasons\n     */\n    get reasonsData(): Array<umi.Reason> {\n        return this.reasons.map((code) => {\n            return umi.reason.get(code)!;\n        });\n    }\n\n    /**\n     * Get the time of quota being restored\n     */\n    get restoreTime(): number {\n        return this.confirmedTime + (14 * 24 * 3600 * 1000);\n    }\n\n    /**\n     * Serialize to JSON\n     */\n    get json(): any {\n        let json: any = {\n            id: this.id,\n            title: this.title,\n            image: this.image,\n            status: this.status,\n            confirmedTime: this.confirmedTime / 1000,\n            confirmationMailId: this.confirmationMailId,\n        };\n        if (this.scanner != umi.ScannerCode.Unknown) {\n            json.scanner = this.scanner;\n        }\n        if (this.reasons.length > 0) {\n            json.reasons = this.reasons;\n        }\n        if (this.resultTime) json.resultTime = this.resultTime / 1000;\n        if (this.resultMailId) json.resultMailId = this.resultMailId;\n        if (this.lngLat) {\n            json.lngLat = {\n                lng: this.lngLat.lng,\n                lat: this.lngLat.lat\n            };\n        }\n        return json;\n    }\n\n    /**\n     * Merge from another nomination\n     * @param nomination The nomination to merge from\n     * @returns Succeed or not\n     */\n    merge(nomination: Nomination): boolean {\n        if (this.id !== nomination.id) return false;\n        if (this.status === umi.StatusCode.Pending) {\n            this.title = nomination.title;\n            this.status = nomination.status;\n            this.reasons = nomination.reasons;\n            this.resultTime = nomination.resultTime;\n            this.resultMailId = nomination.resultMailId;\n        } else {\n            this.confirmedTime = nomination.confirmedTime;\n            this.confirmationMailId = nomination.confirmationMailId;\n        }\n        if (!this.lngLat) {\n            this.lngLat = nomination.lngLat;\n        }\n        return true;\n    }\n\n    /**\n     * Parse nomination from JSON\n     * @param json JSON to be parsed\n     * @throws An `Error` when JSON missing `id`, `title`, `image` or `confirmedTime`\n     */\n    static parse(json: any): Nomination {\n        if (!json.id) throw new Error(StringKey.messageParseErrorMissingId);\n        if (!json.title) throw new Error(StringKey.messageParseErrorMissingTitle);\n        if (!json.image) throw new Error(StringKey.messageParseErrorMissingImage);\n\n        // Fix old issues\n        const image = (json.image as string).replace('\\r', '');\n\n        // Test format\n        if (!/^[a-zA-Z0-9]+$/.test(json.id)) {\n            throw new Error(StringKey.messageParseErrorInvalidId);\n        }\n        if (!/^[0-9a-zA-Z\\-\\_]+$/.test(image)) {\n            throw new Error(StringKey.messageParseErrorInvalidImage);\n        }\n\n        const nomination = new Nomination();\n        nomination.id = json.id;\n        nomination.title = json.title;\n        nomination.image = image;\n\n        if (json.scanner) {\n            nomination.scanner = json.scanner;\n        }\n\n        if (json.status === umi.StatusCode.Pending) {\n            nomination.status = umi.StatusCode.Pending;\n        } else if (json.status === umi.StatusCode.Accepted) {\n            nomination.status = umi.StatusCode.Accepted;\n        } else {\n            nomination.status = umi.StatusCode.Rejected;\n            if (json.status !== umi.Reason.undeclared) {\n                if (umi.reason.has(json.status)) {\n                    nomination.reasons.push(json.status);\n                }\n            }\n        }\n        if (json.reasons) {\n            for (const code of json.reasons) {\n                if (umi.reason.has(code) && !nomination.reasons.includes(code)) {\n                    nomination.reasons.push(code);\n                }\n            }\n        }\n\n        nomination.confirmedTime = json.confirmedTime > Nomination.timestampSecondBound ? json.confirmedTime : json.confirmedTime * 1000;\n        nomination.confirmationMailId = json.confirmationMailId;\n\n        if (json.resultTime) nomination.resultTime = json.resultTime > Nomination.timestampSecondBound ? json.resultTime : json.resultTime * 1000;\n        if (json.resultMailId) nomination.resultMailId = json.resultMailId;\n\n        if (json.lngLat) {\n            nomination.lngLat = {\n                lng: json.lngLat.lng,\n                lat: json.lngLat.lat,\n            }\n        }\n        return nomination;\n    }\n\n    /**\n     * Convert hash part of image URL to short ID\n     * @param imgUrl Hash part of the image URL\n     */\n    static parseId(imgUrl: string): string {\n        return imgUrl.replace(/[^a-zA-Z0-9]/g, '').slice(-10).toLowerCase();\n    }\n}\n\n/**\n * Callback for Array<Nomination>.filter()\n */\nexport type Predicator = (nomination: Nomination) => boolean;","export namespace preferences {\n\n    export function set<T>(key: string, value: T) {\n        localStorage.setItem(key, JSON.stringify(value));\n    }\n\n    export function get<T>(key: string, def: T): T {\n        const value = localStorage.getItem(key);\n        if (value !== null) return JSON.parse(value);\n        return def;\n    }\n\n    export namespace google {\n        \n        const keySync = 'potori.pref.google.sync';\n        \n        export function sync(): boolean {\n            return preferences.get(keySync, false);\n        }\n        export function setSync(value: boolean) {\n            preferences.set(keySync, value);\n        }\n    }\n}","export * from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../node_modules/vue-loader-v16/dist/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader-v16/dist/index.js??ref--0-1!./App.vue?vue&type=style&index=0&id=0f4c9736&lang=scss\"","<template>\n<router-view/>\n</template>\n\n<style lang=\"scss\">\n@use '~@material/typography';\n@import url('https://fonts.googleapis.com/css?family=Roboto:300,400,500&display=swap');\n\nbody {\n    margin: 0;\n}\n\n#app {\n    @include typography.base();\n\n    > main {\n        margin-bottom: env(safe-area-inset-bottom);\n        margin-left: env(safe-area-inset-left);\n        margin-right: env(safe-area-inset-right);\n    }\n}\n</style>\n","import { render } from \"./App.vue?vue&type=template&id=0f4c9736\"\nconst script = {}\n\nimport \"./App.vue?vue&type=style&index=0&id=0f4c9736&lang=scss\"\nscript.render = render\n\nexport default script","import { createRouter, createWebHashHistory, RouteRecordRaw } from 'vue-router';\n\nconst routes: Array<RouteRecordRaw> = [\n    {\n        path: '/',\n        name: 'Dashboard',\n        component: () => import(/* webpackChunkName: \"dashboard\" */ '@/views/Dashboard.vue')\n    },\n    {\n        path: '/list',\n        name: 'List',\n        component: () => import(/* webpackChunkName: \"list\" */ '@/views/NominationList.vue'),\n    },\n    {\n        path: '/details',\n        name: 'Details',\n        component: () => import(/* webpackChunkName: \"details\" */ '@/views/NominationDetails.vue'),\n    },\n    {\n        path: '/map',\n        name: 'Map',\n        component: () => import(/* webpackChunkName: \"map\" */ '@/views/NominationMap.vue'),\n    },\n    {\n      path: '/preferences',\n      name: 'Preferences',\n      component: () => import(/* webpackChunkName: \"preferences\" */ '@/views/Preferences.vue')\n    },\n\n    {\n        path: '/match',\n        name: 'Match',\n        component: () => import(/* webpackChunkName: \"match\" */ '@/views/MatchView.vue')\n    },\n];\n\nconst router = createRouter({\n    history: createWebHashHistory('/next/'),\n    routes: routes,\n});\n\nexport default router\n","import { createApp } from 'vue';\n\nimport App from './App.vue';\nimport router from './router';\nimport store from './store';\nimport { service } from './service';\n\nservice.init(store);\ncreateApp(App)\n    .use(store)\n    .use(router)\n    .mount('#app');\n","import data from '@/data/umi/umi.json';\nimport { Predicator } from '@/service/nomination';\n\n/**\n * Keep all status data\n */\nexport namespace umi {\n\n    /**\n     * Code to identify scanner\n     */\n    export enum ScannerCode {\n        Unknown     = 0,\n        Redacted    = 1,\n        Prime       = 2,\n    }\n    \n    /**\n     * Scanner information\n     */\n    export class Scanner {\n        readonly code: ScannerCode;\n        readonly title: string;\n\n        readonly predicator: Predicator;    // Predicator for filter\n\n        constructor(code: ScannerCode, title: string) {\n            this.code = code;\n            this.title = title;\n            this.predicator = (nomination) => nomination.scanner === this.code;\n        }\n    }\n\n    /**\n     * Code to identify status\n     */\n    export enum StatusCode {\n        Pending     = 0,\n        Accepted    = 1,\n        Rejected    = 101,\n    }\n\n    /**\n     * Code to identify reason\n     */\n    export type ReasonCode = number;\n    \n    /**\n     * Status information\n     */\n    export class Status {\n\n        readonly code: StatusCode; // Code to identify the status and saved in file\n        readonly title: string; // Title to display\n        readonly icon: string;  // Icon to represent the status\n    \n        readonly queries: Map<ScannerCode, string>;  // Queries to search mails, <scanner, query>\n\n        readonly predicator: Predicator;    // Predicator for filter\n    \n        constructor(\n            code: number, title: string, icon: string,\n            queries: Map<ScannerCode, string>\n        ) {\n            this.code = code;\n            this.title = title;\n            this.icon = icon;\n\n            this.queries = queries;\n            this.predicator = (nomination) => nomination.status === this.code;\n        }\n    }\n    \n    /**\n     * Reason information\n     */\n    export class Reason {\n\n        static undeclared: ReasonCode = 101;\n        static duplicated: ReasonCode = 102;\n        static close: ReasonCode = 103;\n\n        //readonly key: string;   // Key of the status\n        readonly code: ReasonCode; // Code to identify the status and saved in file\n        readonly title: string; // Title to display\n        readonly icon: string;  // Icon to represent the status\n    \n        readonly color: string; // Color to represent the reason in charts\n        readonly keywords: Map<ScannerCode, Array<string>>;  // Keywords to identify the reason, <scanner, keywords>\n\n        readonly predicator: Predicator;    // Predicator for filter\n    \n        constructor(\n            code: number, title: string, icon: string,\n            color: string, keyword: Map<ScannerCode, Array<string>>\n        ) {\n            this.code = code;\n            this.title = title;\n            this.icon = icon;\n\n            this.color = color;\n            this.keywords = keyword;\n\n            if (code === Reason.undeclared) {\n                this.predicator = (nomination) => nomination.status === StatusCode.Rejected && nomination.reasons.length < 1;\n            } else {\n                this.predicator = (nomination) => nomination.status === StatusCode.Rejected && nomination.reasons.indexOf(code) > -1;\n            }\n        }\n    }\n\n    /**\n     * Common type of `Scanner`, `Status` and `Reason`\n     */\n    export type CommonSense = Scanner | Status | Reason;\n    \n    export const scanner = data.scanners.reduce((map, json) => {\n        const scanner = new Scanner(json.code, json.title);\n        map.set(scanner.code, scanner);\n        return map;\n    }, new Map<ScannerCode, Scanner>());\n\n    export const status = data.statuses.reduce((map, json) => {\n        const status = new Status(\n            json.code, json.title, json.iconFA,\n            json.queries.reduce((quries, query) => {\n                quries.set(query.scanner, query.query);\n                return quries;\n            }, new Map<ScannerCode, string>())\n        );\n        map.set(status.code, status);\n        return map;\n    }, new Map<StatusCode, Status>());\n\n    export const reason = data.reasons.reduce((map, json) => {\n        const reason = new Reason(\n            json.code, json.title, json.iconFA, json.color,\n            json.keywords.reduce((mapKeywords, keywords) => {\n                mapKeywords.set(keywords.scanner, keywords.keywords);\n                return mapKeywords;\n            }, new Map<ScannerCode, Array<string>>())\n        );\n        map.set(reason.code, reason);\n        return map;\n    }, new Map<ReasonCode, Reason>());\n}"],"sourceRoot":""}